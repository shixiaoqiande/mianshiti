<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
	<script>
		// 判断一个字符串是不是一个回文字符串
			// var str = '12321'
			// function huiwen(str){
			// 	var restr = str.split('').reverse().join('');
			// 	if(str===restr){
			// 		return true
			// 	}else{
			// 		return false
			// 	}
			// }
			// console.log(huiwen(str))
		
		// holle-world 格式转驼峰格式 holleWorld
			// 1. es5
				// var str = 'holle-world-sxq';
				// function strChange(str){
				// 	var arr = str.split('-');
				// 	var newstr = arr[0]
				// 	for(var i=0;i<arr.length;i++){
				// 		if(i!=0){
				// 			var before = arr[i].split('')[0];
				// 			var after = before.toUpperCase()
				// 			newstr+=arr[i].replace(before,after)
				// 		}
				// 	}
				// 	return newstr;
				// }
				// console.log(strChange2(str))
			// 2. reduce
				// let str = "my_name_is_sxq";
				// let result = str.split('').reduce((p,n,i,arr)=>{
				// 	if(n=='_'){
				// 		arr[i+1] = arr[i+1].toUpperCase()
				// 		return p
				// 	}
				// 	return p + n
				// })
				// console.log(result)
			// 3. 正则
				// let ze = /_(\w)/g
				// let result = str.replace(ze,function(_,c){
				// 	console.log(_,c)
				// 	return c.toUpperCase()
				// })
				// console.log(result)
			// 4. 正则封装 vue源码
				// function cached (fn) {
				//     var cache = Object.create(null);
				//     return (function cachedFn (str) {
				//       var hit = cache[str];
				//       return hit || (cache[str] = fn(str))
				//     })
				// }
				// var camelizeRE = /_(\w)/g;
				// var camelize = cached(function (str) {
				//     return str.replace(camelizeRE, function (_, c) { 
				//     	console.log(_,c)
				//     	return c ? c.toUpperCase() : ''; })
				// });
				// console.log(camelize(str))

		// 判断字符串出现次数最多的字符 及 次数
			// es5
				// let str = "http://www.yunjianit.com";
				// function word(str){
				// 	let obj = {};
				// 	let num = 0;
				// 	let key = [];
				// 	for(var i=0;i<str.length;i++){
				// 		let strs = str[i]
				// 		if(!obj[strs]){
				// 			obj[strs] = 1;
				// 		}else{
				// 			obj[strs]++
				// 		}
				// 	}
				// 	for(var i in obj){
				// 		if(num<obj[i]){
				// 			num = obj[i]
				// 		}
				// 	}
				// 	for(var i in obj){
				// 		if(obj[i]==num){
				// 			key.push(i)
				// 		}
				// 	}
				// 	return "出现次数最多的字符为"+key.join('和')+"，出现次数为"+num+"次。"
				// }
				// console.log(word(str))
			// reduce
				// let str = "http://www.yunjianit.com";
				// let result = str.split('').reduce((prev,item,index,arr)=>{
				// 	if(prev[item]){
				// 		prev[item]++
				// 	}else{
				// 		prev[item] = 1
				// 	}
				// 	return prev
				// },{})
				// console.log(result)

		// 写一个程序打印 1 到 100 这些数字，遇到数字为 3 的倍数，打印 “A” 替代该数字；遇到 5 的倍数，用 “B” 代替；遇到即是 3 的倍数又是 5 的倍数，打印 “AB”。
			// 1. 打印 字符串
				// function num(){
				// 	let str = "";
				// 	let a;
				// 	for(var i=1;i<=100;i++){
				// 		if(i%3==0&&i%5==0){
				// 			a = "AB "
				// 		}else if(i%3==0){
				// 			a = "A "
				// 		}else if(i%5==0){
				// 			a = "B "
				// 		}else{
				// 			a = i+" "
				// 		}
				// 		str+=a;
				// 	}
				// 	return str;
				// }
				// console.log(num())
			// 2. 打印 数组
				// function num1(){
				// 	let arr = [];
				// 	let a;
				// 	for(var i=1;i<=100;i++){
				// 		if(i%3==0&&i%5==0){
				// 			a = "AB"
				// 		}else if(i%3==0){
				// 			a = "A"
				// 		}else if(i%5==0){
				// 			a = "B"
				// 		}else{
				// 			a = i
				// 		}
				// 		arr.push(a);
				// 	}
				// 	return arr;
				// }
				// console.log(num())

		// 给定线段 1(x1,y1)(x2,y2) 和 2(x3,y3)(x4,y4) 求线段交点
			// let line1 = [{x1:0,y1:1},{x2:0,y2:-1}];
			// let line2 = [{x3:0,y3:-1},{x4:2,y4:1}];
			// function point(line1,line2){
			//     let [{x1,y1},{x2,y2}] = line1;
			// 	let [{x3,y3},{x4,y4}] = line2;
			// 	let k1 = (y1-y2)/(x1-x2);
			// 	let b1 = y1 - (k1*x1);
			// 	let k2 = (y3-y4)/(x3-x4);
			// 	let b2 = y3 - (k2*x3);
			// 	let a;
			// 	let b;
			// 	if(x1==x2){
			// 		k1,b1 = 0;
			// 		a = x1;
			// 		b = k2*a + b2;
			// 	}
			// 	if(x3==x4){
			// 		k2,b2 = 0;
			// 		a = x3;
			// 		b = k1*a + b1;
			// 	}
			// 	if(((a>x1&&a<x2)||(a<x1&&a>x2)||a==x1||a==x2)&&((a>x3&&a<x4)||(a<x3&&a>x4)||a==x3||a==x4)&&x1!=x2&&x3!=x4){
			// 		a = (b2-b1)/(k1-k2);
			// 		b = k1*a + b1;
			// 	}
			// 	let str;
			// 	if(a!==undefined&&b!==undefined){
			// 		str = `交点为(${a},${b})`
			// 	}else if((k1==k2)&&(b1==b2)&&(((x1==x3)&&(x2==x4))||((x1==x4)&&(x2==x3)))){
			// 		str = "两线段重合"
			// 	}else if(k1==k2){
			// 		str = "两线段平行"
			// 	}else{
			// 		str = "两线段不相交"
			// 	}
			// 	return str;
			// }
			// console.log(point(line1,line2))

		// 斐波那契数列
			// 递归
				// function numArr(num){
				// 	if(num==1||num==2){
				// 		return 1;
				// 	}
				// 	let nums = numArr(num-1)+numArr(num-2)
				// 	return nums
				// }
				// console.log(numArr(6),arr)
			// 非递归
				// let a = 1;
				// let b = 1;
				// let c;
				// let num = 5;
				// let arr = [a,b];
				// for(var i=0;i<num-2;i++){
				// 	c = a+b;
				// 	arr.push(c)
				// 	a = b;
				// 	b = c;
				// }
				// console.log(c,arr)

		// 考察this
			// var length = 10;
			// function fn() {
			//   console.log(this.length);
			// }
			// var obj = {
			//   length: 5,
			//   method: function(fn) {
			//     fn();
			//     arguments[0]();
			//   }
			// };
			// obj.method(fn, 1); 
			// 10
			// 2
			// 第一个是因为函数的this指向全局window
			// 第二个指向arguments

		// JavaScript中如何检测一个变量是一个String类型？请写出函数实现
			// typeof(obj) === "string"
			// typeof obj === "string"
			// obj.constructor === String

		// 检测数据类型
			// typeof
			// instanceof
			// constroctor
			// Object.prototype.toString.call()

		// 树林里有一群猴子，每天自然死一只，猎人一天杀一半，第六天时，只剩下了一只猴子，原来一共有多少只猴子。
			// function hou(last,day){
			// 	while(day!=1){
			// 		last = last*2 + 1
			// 		day--
			// 	}
			// 	return last;
			// }
			// console.log(hou(1,6))

		// 对象转换
			// var obj = {
			// 	"name": {
			// 	    "type": "string",
			// 	    "desc": "病人姓名",
			// 	    "testData": "张三李四",
			// 	    "sex": {
			// 	        "type": "object",  // 这里的type为object
			// 	        "desc": "性别",    // 如果同级的type为object,需要删除这个字段
			// 	        "testData": "男",   // 如果同级的type为object,需要删除这个字段
			// 	        "city": {
			// 	            "type": "string",
			// 	            "desc": "城市",
			// 	            "testData": "杭州"
			// 	        },
			// 	        "street": {
			// 	            "type": "string",
			// 	            "desc": "街道",
			// 	            "testData": "浦口街道"
			// 	        }
			// 	    }
			// 	},
			// 	"order": {
			// 	    "type": "string",
			// 	    "desc": "订单",
			// 	    "testData": "名称"
			// 	}
			// }
			// Object.entries 遍历对象 返回一个二维数组
			// var obj = { foo: 'bar', baz: 42 };
			// console.log(Object.entries(obj)); // [ ['foo', 'bar'], ['baz', 42] ]
			// function a(obj){
			// 	let _obj = {};
			//     if(obj['type']&&obj['type']==='object'){
			//         let items={},flag=false;
			//         Object.entries(obj).forEach(([key, value]) => {
			//             if (key==='type') {
			//                 _obj[key] = value
			//             } else if(typeof(value)==='object'){
			//                 flag=true;
			//                 items[key]=a(value);
			//             }
			//         })
			//         if(flag){
			//             _obj['items'] = items;
			//         }
			//     }else{
			//         Object.entries(obj).forEach(([key, value]) => {
			//             if (typeof(value)!=='object') {
			//                 _obj[key] = value
			//             } else {
			//                 _obj[key]=a(value);
			//             }
			//         })
			//     }
			//     return _obj
			// }
			// console.log(a(obj))

		// 生命周期
			// 用 keep-alive 包裹
			// activited 激活
			// deactivated 禁用
			// 什么时候发请求 宜早不宜迟
				// created
			// 监听数据改变
				// updated
			// 页面加载后改变
				// mounted
			
		// 捕获异常的方法
			// try catch finally
			// try { 
		        // ...  throw "...";
		    // }
		    // catch(err) {
		    //     message.innerHTML = "输入的值 " + err;
		    // }
		    // finally {
		    //     document.getElementById("demo").value = "";
		    // }
		    
		// 事件轮询
			// js 的三大主线程 
				// GUI渲染主线程 视图层
				// js执行主线程 js逻辑
				// 事件监听主线程 事件监听 
				// 一遍一遍的查看事件
				
		// === 和 ==
			// == 判断之前会先转换数据类型
				// 转换规则
					// 如果两个操作数有且仅有一个是数字，就转为数字。
					// 如果两个操作数有且仅有一个是布尔，就转为数字。
					// 如果两个操作数有且仅有一个是对象，就转为值类型（toString）。
					
		// 如何判断一个数组是否为空数组
			// length 
			// pop
			// push

		// 数组合并同类项
			// var a = [
			// 	["03-12", "33.87"],
			// 	["03-15", "34.67"],
			// 	["03-18", "1.13"],
			// 	["03-18", "1.00"],
			// 	["03-18", "1.00"]
			// ]
			// function getArr(arr){
			// 	let obj = {}
			// 	arr.map(item=>{
			// 		if(!obj[item[0]]){
			// 			obj[item[0]] = item[1]*1
			// 		}else{
			// 			obj[item[0]] += item[1]*1
			// 		}
			// 	})
			// 	return Object.entries(obj)
			// }
			// console.log(getArr(a))
		
		// for循环嵌套定时器
			// 先放在任务队列里 set1 set2 set3 set4 set5
			// for(var i=0;i<5;i++){
			// 	setTimeout(function(){
			// 		var date = new Date()
			// 		console.log(i,date.getTime())
			// 	},1000) // 5 5 5 5 5
			// }
			// 时间间隔 不超过10毫秒 是执行代码差出来的
			// for(let i=0;i<5;i++){ // 作用域
			// 	console.log(i)
			// 	setTimeout(function(){
			// 		console.log(i)
			// 	},1000) // 0 1 2 3 4
			// }
			// for(i=0;i<5;i++){ // 函数传参
			// 	(function(i){
			// 		var i = i
			// 		setTimeout(function(){
			// 			console.log(i)
			// 		},1000)
			// 	})(i)
			// }
			
		// js事件流模型
			// 捕获 冒泡 dom事件流（捕获+冒泡）
		// vue跳转
			// router $router
		// 小程序跳转
			// 
		// 同步异步区别
			// 执行顺序
			// 异步不需要等待
		// es6的map和对象的区别
	</script>
</body>
</html>